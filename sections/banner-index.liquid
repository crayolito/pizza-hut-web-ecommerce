<!-- Estilos css en assets/banner-index.css -->
{{ 'banner-index.css' | asset_url | stylesheet_tag }}

<banner-index>
  <div class="container-secundario bi-index">
    <section class="bi-contenedor-imagen">
      <div class="bi-icono-flecha-atras">
        {% render 'icon-flecha-atras-banner' %}
      </div>
      <img src="{{ 'banner-1.png' | asset_url }}" alt="Banner Principal" width="100%" height="100%">
      <div class="bi-icono-flecha-adelante">
        {% render 'icon-flecha-adelante-banner' %}
      </div>
    </section>
    <section class="bi-informacion-banner">
      <small class="bi-informacion-banner-texto">LA MEJOR PIZZA DEL MUNDO</small>
      <button
        id="phbi-btn-pedir-ahora"
        class="bi-boton-banner"
      >
        <p>PEDIR AHORA</p>
      </button>
    </section>
    <section class="bi-opciones-banner">
      <button class="bi-boton-carrusel">
        {% render 'icon-carrusel-seleccionado' %}
      </button>
      <button class="bi-boton-carrusel">
        {% render 'icon-carrusel-no-seleccionado' %}
      </button>
      <button class="bi-boton-carrusel">
        {% render 'icon-carrusel-no-seleccionado' %}
      </button>
      <button class="bi-boton-carrusel">
        {% render 'icon-carrusel-no-seleccionado' %}
      </button>
    </section>
  </div>
</banner-index>

{% schema %}
{
  "name": "Banner Principal",
  "tag": "section",
  "class": "banner-section",
  "settings": [],
  "blocks": []
}
{% endschema %}

<script>
  class BannerIndex extends HTMLElement {
    constructor() {
      super();
      this.imagenesUso = {
        imagen1: window.assets.banner_1,
        imagen2: window.assets.banner_2,
        imagen3: window.assets.banner_3,
        imagen4: window.assets.banner_4,
        imagen5: window.assets.banner_5,
      };
      this.tiempoTransicion = 3000; // 3 segundos en milisegundos
      this.imagenActual = 0;
      this.totalImagenes = Object.keys(this.imagenesUso).length; // Calculamos dinámicamente
      this.intervaloTransicion = null;
      this.imagenElement = null;
      this.botonesCarrusel = [];
      this.contenedorBotones = null;
    }

    connectedCallback() {
      // Inicializar componentes
      this.inicializarComponentes();
      // Configurar evento para botones de navegación
      this.configurarBotonesNavegacion();

      // Configurar eventos para botones de carrusel
      this.configurarBotonesCarrusel();

      // Configurar evento para mostrar/ocultar flechas en hover
      this.configurarVisibilidadFlechas();

      // Iniciar transición automática
      this.iniciarTransicionAutomatica();

      this.btnPedirAhora = this.querySelector('#phbi-btn-pedir-ahora');
      this.btnPedirAhora.addEventListener('click', () => {
        // Guardar en localStorage el valor para que el Menu Page sepa que hhacer
        localStorage.setItem('phph-itemMenu', 'PIZZAS');
        // Depsue redireccionar
        window.location.href = '/pages/menu';
      });
    }

    inicializarComponentes() {
      // Obtener la imagen principal
      this.imagenElement = this.querySelector('.bi-contenedor-imagen img');

      // Agregar efecto de transición CSS a la imagen
      this.imagenElement.style.transition = 'opacity 0.5s ease-in-out';

      // Obtener el contenedor de botones del carrusel
      this.contenedorBotones = this.querySelector('.bi-opciones-banner');

      // Generar botones dinámicamente según el número de imágenes
      this.generarBotonesCarrusel();

      // Configurar imagen inicial
      this.actualizarImagen(0);
    }

    generarBotonesCarrusel() {
      // Limpiar botones existentes
      this.contenedorBotones.innerHTML = '';

      // Crear nuevos botones según el número de imágenes
      for (let i = 0; i < this.totalImagenes; i++) {
        const boton = document.createElement('button');
        boton.classList.add('bi-boton-carrusel');

        // Asignar el icono correspondiente
        if (i === this.imagenActual) {
          boton.innerHTML = this.obtenerIconoSeleccionado();
        } else {
          boton.innerHTML = this.obtenerIconoNoSeleccionado();
        }

        // Agregar evento al botón
        boton.addEventListener('click', () => {
          this.actualizarImagen(i);
          this.reiniciarTransicionAutomatica();
        });

        // Agregar el botón al contenedor
        this.contenedorBotones.appendChild(boton);
      }

      // Actualizar la referencia a los botones
      this.botonesCarrusel = this.querySelectorAll('.bi-boton-carrusel');
    }

    configurarBotonesNavegacion() {
      // Botón flecha atrás
      const botonAtras = this.querySelector('.bi-icono-flecha-atras');
      botonAtras.addEventListener('click', () => {
        this.mostrarImagenAnterior();
      });

      // Botón flecha adelante
      const botonAdelante = this.querySelector('.bi-icono-flecha-adelante');
      botonAdelante.addEventListener('click', () => {
        this.mostrarImagenSiguiente();
      });
    }

    configurarBotonesCarrusel() {
      // Agregar eventos a cada botón del carrusel
      this.botonesCarrusel.forEach((boton, indice) => {
        boton.addEventListener('click', () => {
          this.actualizarImagen(indice);
          this.reiniciarTransicionAutomatica();
        });
      });
    }

    actualizarImagen(indice) {
      // Actualizar índice actual
      this.imagenActual = indice;

      // Aplicar efecto de transición - fade out
      this.imagenElement.style.opacity = '0';

      // Cambiar la imagen después de que se complete el fade out
      setTimeout(() => {
        // Actualizar la imagen mostrada
        const rutaImagen = this.obtenerRutaImagen(indice);
        this.imagenElement.src = rutaImagen;

        // Aplicar efecto de transición - fade in
        this.imagenElement.style.opacity = '1';
      }, 300); // Esperar 300ms para el fade out

      // Actualizar estado de los botones del carrusel
      this.actualizarBotonesCarrusel();
    }

    obtenerRutaImagen(indice) {
      // Obtener la ruta de la imagen según el índice
      const claves = Object.keys(this.imagenesUso);
      if (indice < claves.length) {
        return this.imagenesUso[claves[indice]];
      }
      // Por defecto, devolver la primera imagen
      return this.imagenesUso.imagen1;
    }

    actualizarBotonesCarrusel() {
      // Actualizar la apariencia de los botones del carrusel
      this.botonesCarrusel.forEach((boton, indice) => {
        // Limpiar el contenido existente
        boton.innerHTML = '';

        // Agregar el icono correspondiente
        if (indice === this.imagenActual) {
          boton.innerHTML = this.obtenerIconoSeleccionado();
        } else {
          boton.innerHTML = this.obtenerIconoNoSeleccionado();
        }
      });
    }

    obtenerIconoSeleccionado() {
      // Template para icono de carrusel seleccionado
      return `{% render 'icon-carrusel-seleccionado' %}`;
    }

    obtenerIconoNoSeleccionado() {
      // Template para icono de carrusel no seleccionado
      return `{% render 'icon-carrusel-no-seleccionado' %}`;
    }

    mostrarImagenSiguiente() {
      // Calcular el siguiente índice (con manejo circular)
      const siguienteIndice = (this.imagenActual + 1) % this.totalImagenes;
      this.actualizarImagen(siguienteIndice);
      this.reiniciarTransicionAutomatica();
    }

    mostrarImagenAnterior() {
      // Calcular el índice anterior (con manejo circular)
      const anteriorIndice = (this.imagenActual - 1 + this.totalImagenes) % this.totalImagenes;
      this.actualizarImagen(anteriorIndice);
      this.reiniciarTransicionAutomatica();
    }

    iniciarTransicionAutomatica() {
      // Iniciar el intervalo para cambiar automáticamente las imágenes
      this.intervaloTransicion = setInterval(() => {
        this.mostrarImagenSiguiente();
      }, this.tiempoTransicion);
    }

    reiniciarTransicionAutomatica() {
      // Reiniciar el temporizador cuando hay interacción manual
      if (this.intervaloTransicion) {
        clearInterval(this.intervaloTransicion);
      }
      this.iniciarTransicionAutomatica();
    }

    configurarVisibilidadFlechas() {
      // Obtener componente principal
      const componentePrincipal = this;
      const flechaAtras = this.querySelector('.bi-icono-flecha-atras');
      const flechaAdelante = this.querySelector('.bi-icono-flecha-adelante');

      // Solo aplicar estos eventos si estamos en desktop
      const esDesktop = window.matchMedia('(min-width: 768px)');

      if (esDesktop.matches) {
        // Por defecto, ocultar flechas en desktop (sobrescribir CSS)
        flechaAtras.style.display = 'none';
        flechaAdelante.style.display = 'none';

        // Mostrar flechas cuando el cursor está sobre el componente
        componentePrincipal.addEventListener('mouseenter', () => {
          flechaAtras.style.display = 'block';
          flechaAdelante.style.display = 'block';
        });

        // Ocultar flechas cuando el cursor sale del componente
        componentePrincipal.addEventListener('mouseleave', () => {
          flechaAtras.style.display = 'none';
          flechaAdelante.style.display = 'none';
        });

        // Escuchar cambios en el tamaño de la ventana
        window.addEventListener('resize', () => {
          if (window.matchMedia('(min-width: 768px)').matches) {
            // En desktop, ocultar flechas por defecto
            flechaAtras.style.display = 'none';
            flechaAdelante.style.display = 'none';
          } else {
            // En móvil, restablecer a los valores CSS
            flechaAtras.style.display = '';
            flechaAdelante.style.display = '';
          }
        });
      }
    }

    // Método para limpiar cuando el componente se elimina
    disconnectedCallback() {
      if (this.intervaloTransicion) {
        clearInterval(this.intervaloTransicion);
      }
    }
  }

  // Registrar el componente personalizado
  customElements.define('banner-index', BannerIndex);
</script>
